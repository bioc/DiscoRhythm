#' Quality Control for DiscoRhythm
#'
#' Functions for executing outlier detection and row filtering workflows
#' prior to rhythmicity analysis.
#'
#' @name discoQC
NULL

#' Perform PCA
#'
#' Calculates PCA results from \code{prcomp} with error handling and outputs
#' suitable for the DiscoRhythm workflow.
#'
#' @param scale logical, whether or not to scale the data prior to PCA, see
#' \link[stats]{prcomp} for more details.
#' @param npcs numeric, number of principal components to use, see
#' \link[stats]{prcomp} for more details.
#'
#' @inheritParams discoPCAoutliers
#'
#' @return output from \link[stats]{prcomp} with an added table element
#'
#' @export
#'
#' @examples
#' Maindata <- discoGetSimu()
#' pca <- discoPCA(Maindata[,-1])
#'
discoPCA <- function(Maindata, scale = TRUE, npcs = 10) {
    if (ncol(Maindata) < 2) stop("Not enough samples for PCA")
    if (nrow(Maindata) < 2) stop("Not enough rows for PCA")

    res <- stats::prcomp(t(Maindata),
                center = TRUE,
                scale. = scale,
                rank. = npcs
                )

    npcs <- min(npcs, ncol(res$x))
    x <- t(summary(res)$importance[, seq_len(npcs)])
    x <- data.frame(PC = rownames(x), x)
    res$table <- x

    return(res)
}

#' Internal function for applying SD cutoff to PCA results
#' Returns a logical indicating which samples are not outliers
#' @keywords internal
#' @return logical indicating which samples are outliers in PCA
discoPCAgetOutliers <- function(x, SDfactor = 3, pcToCut = seq_len(4)) {
    sdVec <- matrixStats::rowSds(t(x[, pcToCut, drop = FALSE])) * SDfactor
    meanVec <- colMeans(x[, pcToCut, drop = FALSE])
    meanMat <- matrix(rep(meanVec, nrow(x)), nrow = nrow(x), byrow = TRUE)
    sdMat <- matrix(rep(sdVec, nrow(x)), nrow = nrow(x), byrow = TRUE)
    isoutlier <- apply(abs(x[, pcToCut,
                            drop = FALSE] - meanMat) > sdMat, 1, any)
    return(!isoutlier)
}

#' @rdname discoQC
#'
#' @inheritParams discoInterCorOutliers
#' @param scale logical, perform scaling before PCA (recomended).
#' @param pcToCut numeric, which PCs to use for outlier detection. It is
#' recomended to select the first X PCs based on which PCs explain a
#' significant amount of variance in the data.
#'
#' @return list containing PCA results and the detected outliers
#'
#' @export
#'
#' @examples
#' Maindata <- discoGetSimu()
#' pca <- discoPCAoutliers(Maindata[,-1])
#'
discoPCAoutliers <- function(Maindata, threshold = 3,
    scale = TRUE, pcToCut = seq_len(4)) {
    res <- discoPCA(Maindata[, -1], scale = scale)
    res$outliers <- !discoPCAgetOutliers(res$x, threshold, pcToCut)
    res
}

#' @rdname discoQC
#'
#' @param Maindata data.frame with the first column containing row IDs and all
#' subsequent columns containing experimental values. Columns should follow the
#' expected naming format described in the vignette.
#' @param Metadata data.frame of sample data, usually generated by
#' using \code{discoParseMeta} on the column names of the Maindata data.frame.
#' @param cor_method character, method of pairwise correlation
#' (see \link[stats]{cor}'s "method" argument for all options).
#' @param threshold numeric, a threshold determining which samples are
#' outliers (for discoInterCorOutliers, in units of thresh_type, for
#' discoPCAoutliers in units of standard deviations).
#' @param thresh_type character indicating threshold type (either standard
#' deviations below the mean, or an absolution correlation value). One of:
#' "sd" or "value".
#'
#' @return A list of 3 objects:
#' 1) outliers - named boolean indicating if the sample is an outlier
#' 2) meanCor - mean of all pairwise correlations for a given sample
#' 3) corMat - Matrix of all pairwise correlation values
#'
#' @export
#'
#' @examples
#' Maindata <- discoGetSimu()
#' CorRes <- discoInterCorOutliers(Maindata[,-1])
#'
discoInterCorOutliers <- function(Maindata, Metadata,
                                    cor_method = "pearson",
                                    threshold = 3,
                                    thresh_type = "SD") {

    if(!(tolower(thresh_type) %in% c("sd","value"))){
        stop("thresh_type must be 'value' or 'SD'")
    }

    mat <- stats::cor(Maindata[, -1], method = cor_method)

    # Remove Diagonal (all 1's) to avoid inflated correlation
    corMat <- mat
    diag(corMat) <- NA

    meanCor <- rowMeans(corMat, na.rm = TRUE)

    if (thresh_type != "value") {
        cutval <- (mean(meanCor) - threshold * stats::sd(meanCor))
    } else {
        cutval <- threshold
    }
    outliers <- meanCor <= cutval

    res <- list(outliers = outliers,
                meanCor = meanCor, corMat = corMat, threshold = cutval)
    res
}

################## Row Replicate Analysis #######################

# Average technical replicates
#' @keywords internal
averageTech <- function(Maindata, Metadata,method = "Median") {
    bioID <- paste0(Metadata$Time,"_",Metadata$ReplicateID)

    # Data matrix
    res <- lapply(unique(bioID), function(I) {
        sidx <- which(bioID == I) + 1
        if (length(sidx) >= 2) {
        if (method == "Median") {
            tmp <- as.data.frame(
                matrixStats::rowMedians(as.matrix(Maindata[, sidx])))
        } else if (method == "Mean") {
            tmp <- as.data.frame(
                    matrixStats::rowMeans2(as.matrix(Maindata[, sidx])))
            } else if (method == "Random") {
                tmp <- as.data.frame((Maindata[, sample(sidx, 1)]))
            } else if (method == "None") {
                tmp <- as.data.frame(Maindata[, sidx])
            }
        } else {
            tmp <- as.data.frame(Maindata[, sidx])
        }
        # Following the original input data naming scheme:
        # <prefix><time>_<unique_id>_<replicate_id>
        # so regressionData can be used as Maindata
        if (method != "None") {
            colnames(tmp) <- paste(Metadata$Time[sidx - 1], "A",
                Metadata$ReplicateID[sidx - 1], sep = "_")[1]
        } else {
            colnames(tmp) <- paste(Metadata$Time[sidx - 1], "A",
                Metadata$ReplicateID[sidx - 1], sep = "_")
        }
        tmp
    })

    res2 <- do.call(data.frame, res)
    regDat <- data.frame("ID" = as.character(Maindata[, 1]), res2)

    # Metadata
    res <- lapply(unique(bioID), function(I) {
        sidx <- which(bioID == I)
        if (length(sidx) >= 2) {
            if (method != "None") {
                tmp <- Metadata[sidx, ][1, ]
            } else {
                tmp <- Metadata[sidx, ]
            }
        } else {
            tmp <- Metadata[sidx, ]
        }
        tmp
    })

    res2 <- do.call(rbind, res)
    regMet <- res2[, -1]

    return(
        list(
            "regDat" = regDat,
            "regMet" = regMet
        )
    )
}

#' @rdname discoQC
#'
#' @inheritParams discoBatch
#' @inheritParams discoInterCorOutliers
#'
#' @export
#'
#' @examples
#' Maindata <- discoGetSimu()
#' Metadata <- discoParseMeta(colnames(Maindata)[-1])
#' ANOVAres <- discoRepAnalysis(Maindata,Metadata)
#'
discoRepAnalysis <- function(Maindata, Metadata,
    aov_method = "Equal Variance",
    aov_pcut = 0.05,
    aov_Fcut = 0,
    avg_method = "Median"
    ) {
    bioID <- paste0(Metadata$Time,"_",Metadata$ReplicateID)

    noAOV <- !(aov_method %in% c("Welch","Equal Variance"))
    norep <- !any(duplicated(bioID)) & !noAOV
    if(norep) warning("No replicates present for discoRepAnalysis,
        can't perform ANOVA")
    # Return the same for aov_method="None" and for
    # the case of no replicates
    if(norep | noAOV){
        allStats <- list(statistic = rep(100, nrow(Maindata)),
            pvalue = rep(0, nrow(Maindata)),
            df.between = rep(0, nrow(Maindata)),
            df.within = rep(0, nrow(Maindata)),
            estimate = rep(0, nrow(Maindata)))
    } else if (aov_method == "Welch") {
        allStats <- matrixTests::row_oneway_welch(Maindata[, -1], bioID)
    } else if (aov_method == "Equal Variance") {
        allStats <- matrixTests::row_oneway_equalvar(Maindata[, -1], bioID)
    }
    idx <- (allStats$pvalue <= aov_pcut) & (allStats$statistic > aov_Fcut)
    res <- averageTech(Maindata[idx, ], Metadata, avg_method)
    res$aovP <- allStats$pvalue
    res$allStats <- allStats

    return(res)
}
